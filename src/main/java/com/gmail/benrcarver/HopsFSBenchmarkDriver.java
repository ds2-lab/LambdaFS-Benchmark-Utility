package com.gmail.benrcarver;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.CollectionType;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import org.apache.commons.cli.*;

import java.io.File;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * The actual driver for the benchmark.
 */
public class HopsFSBenchmarkDriver {
    private static final String DEFAULT_CONFIG_LOCATION = "./benchmark.yaml";

    private static final ArrayList<HopsFSClient> clients = new ArrayList<>();

    /**
     * Parse command-line arguments. Currently, there is possibly just one, which would
     * be the path to the YAML file defining the benchmark.
     * @param args The command-line arguments from the main method.
     */
    private static CommandLine parseArguments(String[] args) {
        Options options = new Options();

        Option yamlFileLocationOpt = new Option("i", "input", true, "The path to the YAMl file containing the benchmark definition.");
        yamlFileLocationOpt.setRequired(false);

        CommandLineParser parser = new GnuParser();
        HelpFormatter formatter = new HelpFormatter();
        CommandLine cmd = null;

        try {
            cmd = parser.parse(options, args);
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            formatter.printHelp("utility-name", options);

            System.exit(1);
        }

        return cmd;
    }

    public static void main(String[] args) throws IOException, ExecutionException, InterruptedException {
        // Parse command-line arguments.
        CommandLine cmd = parseArguments(args);

        // Load the YAML file from the default location or the user-specified location, if the user specified one.
        String configFileLocation = DEFAULT_CONFIG_LOCATION;
        if (cmd.hasOption("input")) {
            configFileLocation = cmd.getOptionValue("input");
        }

        // Parse the YAML file.
        ObjectMapper mapper = new ObjectMapper(new YAMLFactory());
        CollectionType listType = mapper.getTypeFactory().constructCollectionType(ArrayList.class, HopsFSNameNode.class);
        mapper.findAndRegisterModules();

        ArrayList<HopsFSNameNode> nameNodesForBenchmark = mapper.readValue(new File(configFileLocation), listType);

        System.out.println("Parsing NameNode definitions now...");
        System.out.println("There are " + nameNodesForBenchmark.size() + " NameNode(s) to process.");

        // Create the HopsFSClient objects in preparation for the benchmark.
        for (HopsFSNameNode hopsFSNameNode : nameNodesForBenchmark) {
            System.out.println("Creating " + hopsFSNameNode.getNumThreads() + " com.gmail.benrcarver.com.gmail.benrcarver.HopsFSClient objects for NameNode at " + hopsFSNameNode.getNameNodeUri());
            for (int i = 0; i < hopsFSNameNode.getNumThreads(); i++) {
                HopsFSClient client = new HopsFSClient(
                        hopsFSNameNode.getNumRpc(),
                        hopsFSNameNode.getNumQueries(),
                        hopsFSNameNode.getId(),
                        hopsFSNameNode.getNameNodeUri(),
                        hopsFSNameNode.getQuery(),
                        hopsFSNameNode.getDataSource(),
                        hopsFSNameNode.getNdbConnectionUri()
                );

                clients.add(client);
            }
        }

        // Use a ThreadPoolExecutor to drive the benchmark.
        // Example: https://howtodoinjava.com/java/multi-threading/java-callable-future-example/
        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();
        List<Future<BenchmarkResult>> resultsList = new ArrayList<>();

        System.out.println("Starting HopsFSClient objects now.");
        // Fire 'em off.
        for (HopsFSClient client : clients) {
            Future<BenchmarkResult> timeResult = executor.submit(client);
            resultsList.add(timeResult);
        }

        // Keep track of the results per NameNode.
        HashMap<String, List<Double>> resultsPerNameNode = new HashMap<>();

        // All of the time results obtained during the benchmark.
        List<Double> allTimes = new ArrayList<>();

        // Iterate over all of the futures and record the results.
        for (Future<BenchmarkResult> future : resultsList) {
            BenchmarkResult result = future.get();

            // The times generated by this future.
            ArrayList<Double> timeResults = result.getTimeResults();

            // This URI identifies the target NameNode of this particular future/result.
            String associatedNameNodeUri = result.getAssociatedNameNodeUri();

            // Get the list of times associated with this NameNode so we can add the
            // latest results to the list.
            List<Double> associatedNameNodeTimes = resultsPerNameNode.get(associatedNameNodeUri);

            if (associatedNameNodeTimes == null) {
                associatedNameNodeTimes = new ArrayList<Double>(timeResults);
                resultsPerNameNode.put(associatedNameNodeUri, associatedNameNodeTimes);
                allTimes.addAll(timeResults);
            } else {
                // Record the times.
                associatedNameNodeTimes.addAll(timeResults);
                allTimes.addAll(timeResults);
            }
        }

        // Compute the total average and the per-NameNode average.
        for (Map.Entry<String, List<Double>> entry : resultsPerNameNode.entrySet()) {
            String nameNodeUri = entry.getKey();
            List<Double> times = entry.getValue();

            // Compute the sum, with which we will compute the average. Also
            // compute the min and the max.
            double sumofTimes = times.stream().reduce(0.0, Double::sum);
            double maxTime = times.stream().reduce(0.0, Double::max);
            double minTime = times.stream().reduce(maxTime, Double::min);

            // Compute the average.
            double average = sumofTimes / times.size();

            System.out.println("Number of times for NameNode at " + nameNodeUri + ": " + times.size());
            System.out.println("NameNode at " + nameNodeUri + " (AVG/MIN/MAX/ALL):\n" + average + "\n" + minTime
                    + "\n" + maxTime + "\n" + times.toString() + "\n");
        }

        double sumOfAllTimes = allTimes.stream().reduce(0.0, Double::sum);
        double maxTime = allTimes.stream().reduce(0.0, Double::max);
        double minTime = allTimes.stream().reduce(maxTime, Double::min);
        double average = sumOfAllTimes / allTimes.size();

        System.out.println("Total number of times collected: " + allTimes.size());
        System.out.println("HopsFS Aggregate Results (AVG/MIN/MAX/ALL):\n" + average + "\n" + minTime
                + "\n" + maxTime + "\n" + allTimes.toString() + "\n");
    }
}
